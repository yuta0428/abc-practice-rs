use std::cmp;

use proconio::input;
// use itertools::Itertools;

fn main() {
    input! {
        n: usize,
    }

    // 頂点i,jの重みDij
    let mut d = vec![vec![0u64; n]; n ];
    for i in 0..n {
        input! {
            di: [u64; n - 1 - i],
        }
        for (j, dij) in di.iter().enumerate() {
            d[i][i + j + 1] = *dij; // 後で頂点i,jでアクセスするため合わせた配列の形にしてる
        }
    }

    /* 解説: https://atcoder.jp/contests/abc318/editorial/7066
        選んだ頂点i1,i2,...,ikをbitで管理し、選んだ辺の重みの総和の最大値を求める。
        条件より、選んだ端点は相異なるため、全ての頂点を選んだときの重みの総和の最大値を求ればよい。
        つまり、dp[2^N-1]=dp[111...111]のときの値
        4頂点の場合)
            dp[0001] = 頂点1のみなので無効値
            dp[0011] = 頂点1と頂点2を選んだことになる
            dp[0100] = 頂点2のみなので無効値
            dp[0101] = 頂点1と頂点3を選んだことになる
            dp[0110] = 頂点2と頂点3を選んだことになる
            dp[0111] = 頂点1,2,3を選んだことになる=条件に合わないので0のまま無効
            dp[1000] = 頂点3のみなので無効値
            dp[1110] = 頂点2,3,4を選んだことになる=条件に合わないので0のまま無効
            dp[1111] = 頂点1,2,3,4を選んだことになる=組み合わせによるがこの前に求めた総和の最大値で結果的に求まる
     */
    let mut dp = vec![0; 1 << n];
    for b in 0..(1 << n) - 1 { // dp[2^N-1]は計算によって求まるのでdp[2^N-2]を全て試してく
        let mut i: usize = 0;
        while (b >> i) & 1 == 1 {
            i += 1; // bitが立っていない = まだ選ばれてない頂点iをまず決定する
        }

        for j in 1..n { // 頂点iと結ぶまだ選ばれてない頂点jを全て調べる
            if (b >> j) & 1 == 0 {
                let nb = b | (1 << i) | (1 << j); // 新たに2つの頂点を選んだ
                dp[nb] = cmp::max(dp[nb], dp[b] + d[i][j]); // dp[nb]=他の辺の組み合わせで計算された値と比べて大きくなるなら更新
            }
        }
    }
    println!("{}", dp.last().unwrap());
}